# Genesis IDGen：序列号与雪花 ID 生成的设计与实现

Genesis `idgen` 是业务层（L2）的 ID 生成组件，覆盖三类常见需求：本地高性能分布式唯一 ID（Snowflake）、分布式递增序列号（Sequencer）以及集群实例唯一 ID 分配（Allocator）。本文重点介绍这三部分的设计动机、技术原理与使用边界。

---

## 0 摘要

- `Snowflake` 适合生成高吞吐、趋势递增、分布式唯一的 `int64` ID
- `Sequencer` 适合按业务键递增的序列号场景，如消息序号、订单流水号
- `Allocator` 为每个服务实例分配唯一 WorkerID 范围，配合租约机制保活，支持优雅扩缩容
- `UUID()` 提供 UUID v7 格式的字符串主键，适合无需数值解析的通用唯一标识场景
- 三类能力互补覆盖：全局唯一主键用 Snowflake，业务序号用 Sequencer，实例隔离用 Allocator
- 组件遵循 Genesis 规范：显式依赖注入、clog 日志、metrics 指标、xerrors 错误语义

---

## 1 背景：为什么需要三类 ID 能力

业务系统中的 ID 生成需求通常分为三类，各自解决不同的问题。

第一类是全局唯一主键。这类需求要求数据库全局唯一，通常结合数据中心的机器 ID 和业务语义来保证。典型场景包括用户 ID、订单 ID、支付流水号等。这类 ID 需要高并发生成、趋势递增以便排序、占用 64 位整数空间以支持长期扩容。

第二类是业务局部序号。这类需求强调在同一业务维度内严格递增，如会话内的消息序号、某类操作的流水号。它们不需要全局唯一，但同一业务实体内不能重复。典型场景包括 IM 消息序号、业务操作日志序号、批处理任务序号等。

第三类是实例隔离标识。这类需求的目标是标识不同的服务实例或进程，通常用于集群环境下的实例身份区分。典型场景包括服务注册目录中的唯一标识、租约管理中的实例 ID、日志追踪中的源头标识等。

单一 ID 生成方案难以同时满足这三类需求。Snowflake 能够生成全局唯一的 64 位整数 ID，但不支持按业务键递增的序列号。简单的 Redis INCR 虽然可以实现递增，但缺乏批量分配、过期管理等高级特性。UUID 方案虽然通用但占用 128 位字符串空间且无序，无法高效用于数据库索引和范围查询。

`idgen` 组件的设计动机是在 Genesis 规范下提供这三类能力的统一封装，让业务方可以根据场景选择合适的 ID 类型，无需关心底层实现细节。

---

## 2 组件总览与接口形态

`idgen` 对外暴露三套接口，分别对应三种 ID 生成能力。

`Generator` 接口提供 `Next()` 和 `NextString()` 两个方法，用于获取下一个 ID 值。`Next()` 返回 `int64` 类型的数值，`NextString()` 返回带前缀的字符串格式。这种设计满足大多数需要数值 ID 的场景，同时提供字符串形式便于展示。

`Sequencer` 接口提供 `Next(ctx, key)`、`NextBatch(ctx, key, count)`、`Set(ctx, key, value)` 和 `SetIfNotExists(ctx, key, value)` 四个方法。`Next` 获取并递增指定 key 的序列号，`NextBatch` 批量获取连续序列号，`Set` 强制设置当前值，`SetIfNotExists` 仅在 key 不存在时初始化。接口支持通过 WithStep 和 WithTTL 配置步长和过期时间。

`Allocator` 接口提供 `Allocate(ctx)`、`KeepAlive(ctx)` 和 `Stop()` 三个方法。`Allocate` 为当前实例分配唯一 WorkerID，`KeepAlive` 持续保活租约，`Stop` 主动释放租约并清理资源。WorkerID 是 24 位整数，支持最多 1677 万实例的唯一标识。

组件采用统一的初始化模式。构造函数接收配置和可选参数，配置通过 `setDefaults()` 设置默认值，通过 `validate()` 校验合法性。依赖通过 Option 模式注入，支持 `WithLogger`、`WithMeter`、`WithTracer` 等标准选项。

---

## 3 Snowflake：高性能本地唯一 ID

### 3.1 位结构与布局

Snowflake 生成 64 位整数 ID，位布局经过精心设计以平衡不同需求：

- **时间戳（41位）**：使用毫秒级精度，可支持到约 69 年。
- **数据中心 ID（5位）**：支持最多 32 个数据中心的唯一标识。
- **工作节点 ID（5位）**：支持每个数据中心下 32 个工作节点的标识。
- **序列号（12位）**：每毫秒最多生成 4096 个 ID。在单机场景下恒为 0，分布式场景下可通过 NTP 同步保证单调递增。

这种位布局确保了时间排序能力，同时通过数据中心和工作节点的分层设计支持多机房部署。

### 3.2 时钟回拨策略

分布式环境下的时钟不同步是 Snowflake 面临的主要挑战。不同节点产生的 ID 可能出现时间倒流，导致数据库索引和排序混乱。`idgen` 的 Snowflake 实现采用了三级时钟回拨策略来处理这个问题。

**本地校验**：当前实现维护一个本地时钟变量，每次生成 ID 时都会读取。如果发现当前时间小于上次记录的时间，说明系统时钟发生了回拨，会记录警告日志并返回 `-1`，同时更新本地时钟为最大值。回拨超过配置阈值时，会触发时钟校验失败错误。

**NTP 同步**：更激进的策略是利用 NTP 同步。`idgen` 并不内置 NTP 客户端，而是建议在部署环境中配置定时同步任务。对于容器环境，可以将宿主机的 `/dev` 映射到容器内，或使用 systemd-timesyncd 等服务。对于虚拟机环境，可以配置时间同步参数确保时钟稳定性。

这种设计在保证时间单调性的同时提供了灵活的容错机制。日志中的 clock backwards 警告可以帮助运维人员及时发现时钟问题。

### 3.3 并发模型与 CAS 状态机

Snowflake 使用无锁的 CAS（Compare And Swap）操作更新序列号状态。这比传统的互斥锁性能更高，同时在单机场景下避免了锁开销。

实现中每个序列号对应一个 `uint64` 类型的状态变量，存储当前序列号和生成次数。生成新的 ID 时，首先读取当前状态，然后通过 `atomic.AddUint64` 原子操作递增序列号，最后使用 `atomic.LoadUint64` 存回新状态。

这种设计保证了序列号的严格递增性和唯一性。即使在极端的高并发场景下，CAS 状态机也能正确处理竞争，保证每个序列号只被分配一次。状态变量还携带生成次数计数，可用于监控 ID 生成速率。

### 3.4 WorkerID 与数据中心约束

Snowflake 规范定义了 WorkerID 的取值范围是 0 到 1023，这意味着最多支持 1677 万个工作节点。这个数值由 `(1 << 21) - 1` 计算得出，预留了 1 作为未分配的哨兵值。

当前实现从配置读取 `max_datacenter_id` 参数，如果没有设置则使用默认值 1023。生成 ID 时会将 `datacenter_id` 限制在有效范围内，如果超过则返回错误。这防止了无效配置导致的 ID 冲突。

数据中心 ID 的分配策略建议是按机房顺序规划，并在配置文件中明确每个数据中心的编号范围。这样可以避免不同机房之间的 ID 冲突，也便于问题排查。

---

## 4 Sequencer：按键递增的分布式序列号

### 4.1 设计动机

某些业务场景需要严格的递增序列号，而不是全局唯一 ID。典型例子包括 IM 会话内的消息序号、订单状态机中的操作序号、批处理任务的执行序号。这类序列号的特点是在同一个 key 下必须严格递增，但不同 key 之间可以独立并发。

Snowflake 虽然支持趋势递增，但其序列号只有 12 位，每毫秒最多生成 4096 个。这对于高频消息场景可能不够用，且无法按业务维度隔离。`Sequencer` 通过 Redis 的 INCRBY 命令实现了按 key 的无限递增，理论上支持任意大的序列号。

### 4.2 Redis Lua 脚本的原子操作

`Sequencer` 的核心实现依赖于 Redis 的 Lua 脚本执行能力。

**单次获取**：获取序列号的 `Next` 方法首先使用 `INCRBY` 命令递增 key 的值，步长可通过 WithStep 配置，默认是 1。然后使用 `MODULO` 取模运算计算新的序列号，确保在指定的步长范围内循环。

**批量获取**：`NextBatch` 方法通过 Lua 脚本一次性执行多个 `INCRBY` 操作，每个操作对应不同的 key 后缀。这样可以减少网络往返次数，提高批量获取性能。Lua 脚本的原子性保证了即使在高并发场景下，批量分配的序列号也是连续且不重复的。

**初始化**：`Set` 和 `SetIfNotExists` 用于设置序列号的起始值。`Set` 直接覆盖已有值，`SetIfNotExists` 仅在 key 不存在时初始化。这两个方法对于数据迁移和灾备恢复场景非常有用，可以确保序列号从指定的基准开始递增。

### 4.3 步长与 TTL 的权衡

步长参数控制了序列号的递增粒度。较大的步长可以提高批量获取效率，但也意味着更多的序列号被跳过。较小的步长提高了序列号的密度，但增加了 Redis 操作次数。默认步长是 1，适用于大多数需要连续序列号的场景。

TTL 参数控制序列号的过期时间。一旦过期 Redis 会自动删除 key，对应的序列号可以被回收复用。这对于短生命周期业务很有用，可以避免序列号空间的无限膨胀。TTL 设置为 0 表示不过期，序列号永久有效。

这两个参数需要根据业务特性仔细选择。对于长期稳定运行的业务，可以使用较小的步长和较长的 TTL。对于临时性任务，可以使用默认步长并设置较短的 TTL。

### 4.4 过期与续期机制

`Sequencer` 通过后台 goroutine 定期检查已分配序列号的过期情况。对于设置了 TTL 的 key，如果过期时间已过半，会自动执行 `EXPIRE` 续约。续约成功后记录日志，包含续约前后和新的过期时间。这种机制保证长生命周期任务的序列号不会意外过期，同时避免手动续约的复杂性。

---

## 5 Allocator：实例唯一 ID 分配与租约保活

### 5.1 分配机制与 WorkerID

`Allocator` 用于为每个服务实例分配唯一的 24 位 WorkerID。WorkerID 的取值范围是 0 到 1677 万，理论上可以支持大规模集群部署。分配算法采用环形扫描策略，从 0 开始递增查找可用的 WorkerID。

这种设计解决了多实例环境下实例标识的问题。每个服务实例启动时向 `Allocator` 申请一个 WorkerID，之后所有该实例生成的业务 ID 都可以携带这个 WorkerID 作为前缀。这样可以实现按实例的流量统计、问题排查和灰度发布。

### 5.2 租约保活与优雅退出

`Allocator` 的 KeepAlive 方法用于续约已分配的 WorkerID。组件会启动后台 goroutine，定期向 Redis 发送刷新请求。续约逻辑使用 Lua 脚本中的 `EXPIRE` 命令延长过期时间。如果续约失败达到阈值，会触发进程退出或摘流量。

这种机制确保了长时间运行的服务实例不会因为租约过期而突然中断。续约失败时可以选择是立即重启还是优雅退出，满足不同业务场景的需求。`Stop` 方法会主动释放所有已分配的 WorkerID，并停止保活 goroutine。

### 5.3 Redis 后端实现

`Allocator` 支持 Redis 和 Etcd 两种后端实现。Redis 实现使用自定义的 key 前缀和 Lua 脚本，Etcd 实现利用原生的租约 API。两种方式通过配置的 Driver 字段选择，都是标准接口实现。

Redis 实现的 key 格式为 `genesis:idgen:lease:{workerID}`。获取租约时会检查 key 是否存在，如果存在说明租约仍有效，直接续约；如果不存在则重新获取租约。Etcd 实现使用 `clientv3.Lease` API，租约的 KeepAlive 由服务器自动处理。

### 5.4 使用模式与最佳实践

典型使用流程是服务启动时初始化 `Allocator`，在 `defer` 中调用 `Stop` 确保资源释放。业务代码中通过 `Allocate` 获取 WorkerID 后，可以将其配置到其他组件的日志和追踪上下文中，便于关联请求与实例标识。

对于需要长期稳定运行的服务，建议使用较大的 WorkerID 池和较长的 TTL。对于临时性任务或测试环境，可以使用默认配置。多机房部署时建议配置 `max_datacenter_id` 明确各机房的 ID 范围。

---

## 6 UUID：通用唯一标识的补充

`idgen.UUID()` 方法提供了 Google UUID v7 格式的字符串主键。UUID v7 由 122 位十六进制字符组成，占用 128 位字符串空间。它的特点是全局唯一性概率极高（碰撞概率约等于 2^122 分之一），包含时间戳和版本信息，但不保证有序性。

UUID 适合不依赖数值解析、需要长期稳定且全球唯一的场景。典型应用包括跨系统的实体关联、分布式追踪的 trace ID、外部系统的引用标识等。但由于占用空间大且无序，不适合高频数据库索引和范围查询。

---

## 7 设计权衡与最佳实践

### 7.1 选型建议

对于需要全局唯一主键且对排序敏感的场景，优先选择 Snowflake。它的 64 位整数 ID 既支持数据库索引，又天然携带时间排序信息，占用空间小且性能高。对于单机场景，Snowflake 无锁 CAS 的并发模型比 Redis 等方案延迟更低。

对于需要按业务键严格递增的序列号场景，优先选择 Sequencer。它的 Redis INCR 实现理论上无上限，支持多 key 并行，Lua 脚本保证原子性。步长和 TTL 参数提供了灵活的过期和复用策略。

对于需要实例唯一标识且支持动态扩缩容的场景，优先选择 Allocator。它的租约机制保证了节点在健康时持有 ID，异常时自动释放。24 位 WorkerID 支持大规模集群，环形分配策略实现了高效的资源复用。

### 7.2 配置关键点

Snowflake 的关键配置是 `datacenter_id` 和 `worker_id`。这两个参数决定了 ID 的空间范围和唯一性约束，必须在部署时明确规划并录入配置。Sequencer 的 `step` 参数控制了递增粒度和并发效率，需要根据业务特点选择。Allocator 的 `ttl` 参数决定了实例 ID 的有效期，过长会增加资源占用，过短会导致频繁重新分配。

### 7.3 监控与告警

组件内置了 Prometheus 指标，包括 `idgen_snowflake_generated_total` 和 `idgen_sequence_generated_total`。建议在生产环境中配置 `WithMeter`，监控 ID 生成速率和序列号消耗情况。对于关键业务，可以设置告警规则，当生成速率异常或序列号即将耗尽时及时通知。

---

## 8 总结

`idgen` 组件通过提供三类 ID 生成能力，覆盖了业务系统中的主要 ID 需求场景。Snowflake 提供高性能的全局唯一 ID，Sequencer 提供按业务键递增的序列号，Allocator 提供实例唯一 ID 并支持租约保活。

组件设计遵循 Genesis 的显式依赖注入和可观测性原则。通过统一的 Generator、Sequencer、Allocator 接口，业务代码可以根据场景选择合适的 ID 类型。三者互补而非替代关系，Snowflake 适用于需要排序和索引的主键场景，Sequencer 适用于需要严格递增的业务序号，Allocator 适用于需要实例标识和动态扩缩容的集群环境。
