# Genesis cache：统一缓存抽象的设计与实现

Genesis `cache` 是业务层（L2）的缓存组件，提供统一的缓存接口与配置模型，在同一套 API 下支持 Redis（分布式）与 Memory（单机）两种驱动。它的目标不是屏蔽所有差异，而是在“统一心智模型”和“保留后端能力”之间取得平衡。

---

## 0. 摘要

- `cache` 通过 `Cache` 接口统一了 Key-Value、Hash、Sorted Set、List、批量操作等能力。
- 驱动由配置 `driver` 决定：`redis`（默认）或 `memory`。
- Redis 驱动支持完整数据结构与序列化存储；Memory 驱动聚焦本地 Key-Value，复杂结构操作显式返回不支持。
- 组件遵循 Genesis 依赖注入规范：日志使用 `clog`，指标接口使用 `metrics`，错误语义使用 `xerrors`。
- 资源所有权清晰：`cache.Close()` 对 Redis 模式是 no-op，底层连接由 `connector` 负责关闭。

---

## 1. 背景：缓存组件要解决的“真实问题”

微服务中缓存通常会面临三类矛盾：

- 业务希望“一套 API 到处用”，但不同后端能力差异很大。
- 团队需要“快速切换本地/分布式模式”，但不想在业务层堆满 if/else。
- 性能优化需要保留底层能力（Pipeline、Lua），不能把抽象做成“最小公约数陷阱”。

`cache` 的定位就是在这些约束下提供一套可落地的折中方案：统一核心操作，明确能力边界，必要时允许下钻到底层客户端。

---

## 2. 核心设计：统一接口 + 配置驱动

### 2.1 接口分层

`Cache` 接口包含四类能力：

- Key-Value：`Set/Get/Delete/Has/Expire`
- 结构化集合（Redis）：`H*`、`Z*`、`L*`
- 批量操作（Redis）：`MGet/MSet`
- 高级能力：`Client()` 暴露底层客户端

这种设计让业务能先按统一语义开发；当需要高级特性时，再通过 `Client()` 进入底层能力。

### 2.2 配置模型

核心配置：

- `driver`: `redis | memory`（默认 `redis`）
- `prefix`: Redis key 前缀
- `serializer`: `json | msgpack`（默认 `json`）
- `standalone.capacity`: Memory 模式最大条目数（默认 `10000`）

初始化路径：

1. `New(cfg, opts...)`
2. `setDefaults()` 补默认值
3. `validate()` 校验驱动合法性
4. 根据 `driver` 分派到 `newRedis` 或 `newStandalone`

### 2.3 依赖注入与生命周期

Redis 模式必须注入 `WithRedisConnector`，否则初始化失败。  
日志和指标可选注入；未注入时使用 `Discard` 空实现。

生命周期规则：

- Redis 模式：`cache` 借用连接器，`Close()` 不关闭底层 Redis 连接。
- Memory 模式：`Close()` 负责停止内部 goroutine。

---

## 3. Redis 驱动设计（分布式模式）

### 3.1 序列化策略

Redis 驱动在写入前统一 `marshal`，读取后统一 `unmarshal`，序列化器可选：

- `json`：兼容性好、可读性强
- `msgpack`：体积更小，编解码性能更优

这意味着缓存层天然支持结构体对象，而不是只支持字符串。

### 3.2 Key 前缀与命名隔离

所有 Redis key 都会经过 `prefix + key` 处理，实现服务级或环境级命名空间隔离，降低 key 冲突风险。

### 3.3 数据结构能力

Redis 模式支持：

- Hash：适合对象局部字段更新与计数器（`HIncrBy`）
- Sorted Set：适合排行榜、时间线窗口（`ZRangeByScore`）
- List：适合队列、最近记录（`LPushCapped`）
- Batch：`MGet/MSet` 减少网络往返

其中 `LPushCapped` 通过 Pipeline 组合 `LPush + LTrim`，实现固定容量列表。

### 3.4 行为边界与注意点

- `HGetAll` 当前仅支持“指向 map 的指针”，不支持直接反序列化到 struct。
- `MGet` 要求 `destSlice` 必须是“切片指针”。
- `Set` 的 `ttl=0` 语义继承 Redis，即不过期。

---

## 4. Memory 驱动设计（单机模式）

### 4.1 底层实现选择

Memory 模式基于 `otter`，配置容量上限并启用写入过期策略，目标是提供轻量、低依赖、可测试的本地缓存。

### 4.2 TTL 语义

- `Set` 时如果传入 `ttl > 0`，按指定 TTL 过期。
- `ttl <= 0` 时使用超长默认 TTL（100 年）模拟“近似永久”。
- 读取不会刷新 TTL（与 Redis 常见语义一致）。

### 4.3 能力边界

Memory 模式仅支持 Key-Value 基础能力；`H*`、`Z*`、`L*`、`MGet/MSet` 都会返回“不支持”错误。  
这是一个有意设计：避免伪造行为一致性，明确告诉调用方当前运行模式能力上限。

### 4.4 引用语义风险

Memory 模式存储的是原始对象引用，`Get` 时做的是浅层赋值。  
如果值中包含 `map/slice/pointer` 等引用类型，调用方修改读取结果可能影响缓存内数据。

结论：把 Memory 模式读取结果视为只读对象；需要修改时先做深拷贝。

---

## 5. 一致性、失效与错误语义

### 5.1 一致性模型

`cache` 本质是“旁路缓存能力组件”，不负责事务一致性。  
业务侧应自行选择策略：

- Cache-Aside（最常见）
- Write-Through / Write-Back（按场景权衡）
- 关键路径加互斥锁或版本号避免并发覆盖

### 5.2 失效策略建议

- 给大多数业务 key 设置明确 TTL，避免永久脏数据。
- 对热点列表使用 `LPushCapped` 控制容量。
- 大规模 key 设计要提前规划前缀与分片策略，避免单前缀过热。

### 5.3 错误语义

组件使用 `xerrors` 返回统一错误，常见包括：

- 配置错误（如未注入 Redis 连接器）
- 参数错误（如目标容器类型不匹配）
- 运行态错误（如 cache miss、后端命令失败）

业务代码应区分“可重试错误”和“业务预期错误”（如 miss）。

---

## 6. 实践模式与选型建议

### 6.1 何时用 Redis 模式

- 多副本服务共享缓存
- 需要 Hash/ZSet/List/批量操作
- 需要跨进程一致的缓存视图

### 6.2 何时用 Memory 模式

- 本地开发与单元测试
- 对单实例热点数据做一级缓存
- 对可降级场景做短时加速

### 6.3 推荐组合

- 业务服务：Redis 作为主缓存。
- 计算密集接口：可叠加进程内短 TTL 缓存（Memory）作为 L1。
- 一致性敏感场景：缓存仅做读优化，写路径以数据库为准。

---

## 7. 设计取舍总结

`cache` 的关键价值不是“隐藏一切差异”，而是：

- 用统一接口覆盖高频缓存场景；
- 用显式错误暴露驱动能力边界；
- 用依赖注入和生命周期约束保障工程可维护性；
- 在需要时允许业务安全地下探到底层客户端。

这让它既能作为通用缓存积木，也能承载高性能场景的定制化优化。
