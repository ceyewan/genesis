# Genesis Cache：统一缓存抽象的设计与实现

Genesis `cache` 是业务层（L2）的缓存组件，提供统一的缓存接口与配置模型，在同一套 API 下支持 Redis（分布式）与 Memory（单机）两种驱动。它的目标不是屏蔽所有差异，而是在统一心智模型和保留后端能力之间取得平衡。

---

## 0 摘要

- `cache` 通过 `Cache` 接口统一了 Key-Value、Hash、Sorted Set、List、批量操作等能力
- 驱动由配置 `driver` 决定：`redis`（默认）或 `memory`
- Redis 驱动支持完整数据结构与序列化存储；Memory 驱动聚焦本地 Key-Value，复杂结构操作显式返回不支持
- 组件遵循 Genesis 依赖注入规范：日志使用 `clog`，指标接口使用 `metrics`，错误语义使用 `xerrors`
- 资源所有权清晰：`cache.Close()` 对 Redis 模式是 no-op，底层连接由 `connector` 负责关闭

---

## 1 背景：缓存组件要解决的"真实问题"

微服务中缓存通常会面临三类矛盾：

- 业务希望一套 API 到处用，但不同后端能力差异很大
- 团队需要快速切换本地/分布式模式，但不想在业务层堆满 if/else
- 性能优化需要保留底层能力（Pipeline、Lua），不能把抽象做成最小公约数陷阱

`cache` 的定位就是在这些约束下提供一套可落地的折中方案：统一核心操作，明确能力边界，必要时允许下钻到底层客户端。

---

## 2 核心设计

### 2.1 接口分层

`Cache` 接口包含四类能力：

- Key-Value：`Set/Get/Delete/Has/Expire`
- 结构化集合（Redis）：`H*`、`Z*`、`L*`
- 批量操作（Redis）：`MGet/MSet`
- 高级能力：`Client()` 暴露底层客户端

这种设计让业务能先按统一语义开发；当需要高级特性时，再通过 `Client()` 进入底层能力。

### 2.2 配置模型

核心配置包括：`driver`（`redis | memory`，默认 `redis`）、`prefix`（Redis key 前缀）、`serializer`（`json | msgpack`，默认 `json`）、`standalone.capacity`（Memory 模式最大条目数，默认 `10000`）。

初始化路径依次为：调用 `New(cfg, opts...)`、`setDefaults()` 补默认值、`validate()` 校验驱动合法性、根据 `driver` 分派到 `newRedis` 或 `newStandalone`。

### 2.3 依赖注入与生命周期

Redis 模式必须注入 `WithRedisConnector`，否则初始化失败。日志和指标可选注入，未注入时使用 `Discard` 空实现。

生命周期规则：Redis 模式下 `cache` 借用连接器，`Close()` 不关闭底层 Redis 连接；Memory 模式下 `Close()` 负责停止内部 goroutine。

---

## 3 Redis 驱动设计

### 3.1 序列化策略

Redis 驱动在写入前统一 `marshal`，读取后统一 `unmarshal`，序列化器可选 `json`（兼容性好、可读性强）或 `msgpack`（体积更小、编解码性能更优）。这意味着缓存层天然支持结构体对象，而不是只支持字符串。

### 3.2 Key 前缀与命名隔离

所有 Redis key 都会经过 `prefix + key` 处理，实现服务级或环境级命名空间隔离，降低 key 冲突风险。

---

## 4 数据结构原理与实现

### 4.1 Hash：字段级对象存储

Redis Hash 是一个 string 类型的 field 和 value 的映射表，适合存储对象。底层实现使用压缩列表（ziplist）和哈希表（hashtable）两种编码：

- **ziplist**：当元素数量小于 `hash-max-ziplist-entries`（默认 512）且所有值长度小于 `hash-max-ziplist-value`（默认 64 字节）时使用。这是一个连续内存块，通过紧凑编码节省内存，但修改操作可能需要 realloc。
- **hashtable**：当超过阈值时升级为哈希表，实现 O(1) 的增删改查。

Hash 的典型场景是对象局部字段更新，如用户资料中仅更新昵称字段，无需整体替换对象。`HIncrBy` 利用 Redis 的原子计数能力，适合点赞数、阅读数等计数器场景。

### 4.2 Sorted Set：跳跃表的有序集合

Sorted Set 是 Redis 中最复杂的数据结构之一，每个元素关联一个 double 类型的 score。底层实现组合了两种结构：

- **skiplist**：核心是有序链表的优化版，通过多层索引实现 O(log N) 的查找、插入、删除。每个节点随机决定层级（类似概率化的二分查找），空间复杂度 O(N) 但常数较小。
- **dict**：哈希表存储 member 到 score 的映射，实现 O(1) 的 ZScore 查询。

两者通过指针共享节点，避免数据冗余。这种设计让 Sorted Set 同时支持高效的分数查询（O(log N)）和成员存在性检查（O(1)）。

典型场景包括排行榜（按分数排序）、时间线窗口（按时间戳作为 score）、范围查询（`ZRangeByScore` 获取分数区间内的元素）。

### 4.3 List：快速双向链表

Redis List 底层使用 quicklist（3.2 版本后），这是 ziplist 和双向链表的混合体：

- 每个节点是一个 ziplist，存储多个连续元素
- 节点间通过双向指针连接
- 既保留了链表两端操作的 O(1) 特性，又通过 ziplist 压缩减少内存碎片

`LPushCapped` 是组件提供的扩展能力，通过 Pipeline 组合 `LPush + LTrim`，实现固定容量的最近记录队列（如保留最近 100 条日志）。

### 4.4 批量操作：Pipeline 减少网络往返

`MGet/MSet` 利用 Redis Pipeline 能力，将多个命令打包发送，一次往返返回所有结果。网络往返从 N 次减少到 1 次，对于高延迟网络场景效果显著。

---

## 5 Memory 驱动设计

### 5.1 底层实现选择

Memory 模式基于 `otter`，配置容量上限并启用写入过期策略，目标是提供轻量、低依赖、可测试的本地缓存。

### 5.2 TTL 语义

`Set` 时如果传入 `ttl > 0`，按指定 TTL 过期；`ttl <= 0` 时使用超长默认 TTL（100 年）模拟近似永久。读取不会刷新 TTL（与 Redis 常见语义一致）。

### 5.3 能力边界

Memory 模式仅支持 Key-Value 基础能力；`H*`、`Z*`、`L*`、`MGet/MSet` 都会返回不支持错误。这是一个有意设计：避免伪造行为一致性，明确告诉调用方当前运行模式能力上限。

### 5.4 引用语义风险

Memory 模式存储的是原始对象引用，`Get` 时做的是浅层赋值。如果值中包含 `map/slice/pointer` 等引用类型，调用方修改读取结果可能影响缓存内数据。结论：把 Memory 模式读取结果视为只读对象；需要修改时先做深拷贝。

---

## 6 一致性、失效与错误语义

### 6.1 一致性模型

`cache` 本质是旁路缓存能力组件，不负责事务一致性。业务侧应自行选择策略：Cache-Aside（最常见）、Write-Through/Write-Back（按场景权衡）、关键路径加互斥锁或版本号避免并发覆盖。

### 6.2 失效策略建议

给大多数业务 key 设置明确 TTL，避免永久脏数据。对热点列表使用 `LPushCapped` 控制容量。大规模 key 设计要提前规划前缀与分片策略，避免单前缀过热。

### 6.3 错误语义

组件使用 `xerrors` 返回统一错误，常见包括：配置错误（如未注入 Redis 连接器）、参数错误（如目标容器类型不匹配）、运行态错误（如 cache miss、后端命令失败）。业务代码应区分可重试错误和业务预期错误（如 miss）。

---

## 7 实践模式与选型建议

### 7.1 何时用 Redis 模式

- 多副本服务共享缓存
- 需要 Hash/ZSet/List/批量操作
- 需要跨进程一致的缓存视图

### 7.2 何时用 Memory 模式

- 本地开发与单元测试
- 对单实例热点数据做一级缓存
- 对可降级场景做短时加速

### 7.3 推荐组合

业务服务使用 Redis 作为主缓存。计算密集接口可叠加进程内短 TTL 缓存（Memory）作为 L1。一致性敏感场景下，缓存仅做读优化，写路径以数据库为准。

---

## 8 设计取舍总结

`cache` 的关键价值不是隐藏一切差异，而是：用统一接口覆盖高频缓存场景，用显式错误暴露驱动能力边界，用依赖注入和生命周期约束保障工程可维护性，在需要时允许业务安全地下探到底层客户端。这让它既能作为通用缓存积木，也能承载高性能场景的定制化优化。
